# -*- coding: utf-8 -*-
"""5. 음식점 추천하기_1차 .ipynb의 사본

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R3XWFX2jQg8E86yGKsXDxWtfuyhy8ilO
"""

# 글씨체 설치, 실행 후 런타임 다시 시작
!sudo apt-get install -y fonts-nanum    
!sudo fc-cache -fv                      
!rm ~/.cache/matplotlib -rf

!pip install konlpy

# 필요한 라이브러리 

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from konlpy.tag import Okt 
from nltk import FreqDist

df = pd.read_csv("/content/drive/MyDrive/파데분/카카오리뷰.csv")

df2 = pd.read_csv("/content/drive/MyDrive/파데분/신촌동카카오리뷰.csv")

df.columns = ['name', 'reviews']
df['location'] = '남가좌1동'

df2.columns = ['name','reviews']
df2['location'] = '신촌동'

df1 = pd.concat([df, df2])

df1.index = range(0,10)

# 남가좌1동과 신촌동 리뷰를 합쳐서 사용하였음.
df1

# 리뷰에서 명사 추출해주는 함수, 직접적으로 사용하지 않고 밑의 update_tokens에서 받아서 사용
def tokenizer(review):
  okt = Okt()
  nouns = okt.nouns(review)
  return [noun for noun in nouns]

# tokenizer 받아서 원래 데이터프레임에 추가해줌, 입력값은 데이터프레임 변수명과 리뷰데이터 열 이름
def update_tokens(df, review_colname):
  a = []
  for i in range(len(df)):
    a.append(tokenizer(df[review_colname][i]))
  df['tokens'] = a
  return df

df = update_tokens(df1, 'reviews')

df

# 사용자에게 지역과 키워드를 입력받는 함수, 직접적으로 사용하지 않고 다른 함수에서 받아서 사용
def conditions():
  query = input('지역? ')
  keywords=[]
  for i in range(3):
    keywords.append(input('키워드: '))
  return query, keywords

# conditions 함수를 받아서 입력한 키워드와 지역이 일치하는 식당을 찾아내는 함수, 마찬가지로 최종 함수에서 받아서 사용할 것임
def matched_store():
  query, keywords = conditions()
  a = df[df['location'] == query]     # 'location'은 동 이름을 저장한 열 이름임. conditions 함수로 사용자가 입력한 지역과 일치하는 데이터만 가져옴
  words = []
  for i in range(len(a)):
    b = []
    fd = FreqDist(a['tokens'][i])
    commons = fd.most_common(5)       # 각 식당의 tokens 중 가장 빈도수가 높은 5개를 찾아서 단어와 빈도수 튜플로 출력. ex> (('맛집', 17), ('최고', 14))
    for k in range(5):
      b.append(commons[k][0])
    words.append(b)
  a['key'] = words                    # 가장 빈도수 높은 단어 다섯개를 dataframe a의 'key' 열로 추가함
  match = []
  for i in range(len(a)):
    if (keywords[0] in a['key'][i]) & (keywords[1] in a['key'][i]) & (keywords[2] in a['key'][i]):
      match.append(a['name'][i])      # 키워드 1,2,3 이 key 열의 다섯 단어에 모두 포함된다면 그 식당 이름을 찾아 match에 저장
  return match, query, keywords

# 파이차트 그리기 위한 값들 계산하기, 최종함수
def for_pie_chart():
  match, query, keywords = matched_store()       # matched_store 함수에서 식당 이름 리스트, 지역, 키워드를 받아옴
  d = {}
  for name in match:                             # match : 식당 이름 리스트, 따라서 일치하는 식당 하나하나씩 계산할 것임
    a = df[df['name'] == name]
    a.index = range(0,1)
    label = keywords + ['기타']                  # label = 키워드 세개와 나머지 단어
    ratio = []
    tok = a.loc[0, 'tokens']                     # tok = 'tokens' 열에 저장된 토큰 리스트 값만 가져오기 
    left = len(tok)                             
    for key in keywords:
      num = tok.count(key)
      ratio.append(num/len(tok))                 # num 은 각 키워드가 토큰 리스트 안에 몇개 있는지 센 값이므로 ratio에 전체 토큰 길이로 나눠준 값을 저장함
      left -= num
    ratio.append(left/len(tok))                  # 각 num 변수를 모두 빼주면 키워드를 제외한 나머지 단어의 개수가 나오므로 다시 전체 토큰 길이로 나눠주고 마지막으로 저장
    d['name'] = name
    d['info'] = [label, ratio]
  return d                                       # 식당 이름을 딕셔너리 키 'name'으로, label 과 ratio 는 키 'info' 에 저장해서 return

d = for_pie_chart()

d

plt.rc('font', family='NanumBarunGothic') 
explode = [0.05, 0.05, 0.05, 0.05]
colors = ['#ff9999', '#ffc000', '#8fd9b6', '#d395d0']
plt.pie(d['info'][1], labels=d['info'][0], autopct='%.1f%%', startangle=260, counterclock=False, explode=explode, shadow=True, colors=colors)  
plt.title(d['name'], size = 15)
plt.show()

